[Cocoa Fundamentals Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974-CH1-SW1)

# 简介

对于开发新手而言，Cocoa 可能像是个汪洋大海，未知的技术的新世界。各种功能，工具，概念，设计，术语，编程接口以及这种开发环境的编程语言都可能不熟悉。Cocoa 基础指南让熟悉 Cocoa 这一初始步骤变得简单。它为 Cocoa 的技术概览提供了方向。它介绍了其功能，基本概念，术语，体系结构和底层设计模式。  
你可以为两个平台构建 Cocoa 应用：OS X 操作系统和 iOS，类似 iPhone，iPad 和 iPod touch 的多点触控设备操作系统。Cocoa 基础指南展现了两个平台中与 Cocoa 相关的信息，尽可能的整合了信息并在必要的位置指出平台的差异。目的是一旦你对 Cocoa 的一个平台熟悉了，很容易就从一个软件开发平台的知识迁移到另一个。  
Cocoa 基础指南意在逐步理解 Cocoa 开发全貌。它从基本信息开始——什么是 Cocoa 遵照的组建和能力——并以查阅其主要架构为止。每个章节都在其前一章节解释了。每个段落都对于一个子模块介绍了详情，但只在一个较高层次进行描述。一个段落会经常将你引用到另一个提供更全面描述的文档。    
在Cocoa 开发文档集合中，《Cocoa 基础指南》是概念入口文档。对于阅读其他基本 Cocoa 指南是先决条件，比如《Cocoa 绘制指南》，《视图编程指南》，以及《iOS 应用编程指南》。《Cocoa 基础指南》会依据先导阅读，但读者应该精通 C 语言编程并属性他们将要进行开发的平台的能力和技术，你可以通过阅读《Mac 技术概览》对此熟悉，对于iOS而言，阅读《iOS 技术概览》。

## 本文档组织结构

Cocoa 基础指南有如下章节：  

* 什么是 Cocoa？ 从功能性和概括性的结构透析介绍了 Cocoa，描述了其功能，框架和开发环境。
* Cocoa 对象 阐释了优势和OC的基本使用，还介绍了常用功能，接口和所有 Cocoa 对象的生命周期。
* 给一个 Cocoa 程序添加行为 描述了使用 Cocoa 框架编写一个程序是什么样的，以及解释了如何创建一个子类。
* Cocoa 设计模式 描述了 Cocoa 适配设计模式，特别是 MVC 和对象模型。
* 与对象进行交互 讨论了编程接口和在 Cocoa 对象之间的沟通机制，包括代理，通知和绑定。

## 另请参阅

在技术书库中你还可以找到很多优秀的第三方介绍 Cocoa 的文章。你可以用这些书补充你在 Cocoa 基础指南中的所学。此外，还有一些其他的 Apple 文章你也可以作为一个 Cocoa 开发者阅读：  

* OC编程语言 描述了OC编程语言和运行时环境。
* 模型对象实现指南 讨论了子类设计和实现的基本问题。
* 开发 Cocoa OC 应用程序 《教程》展示了如何使用Xcode开发环境构建一个简单的 OS X 的 Cocoa 应用程序，Cocoa 框架和 OC。《你的第一个 iOS 应用》是一份引导你从创建一个简单的 iOS 应用到展示如何使用基本的 Xcode 开发环境以及 OC 和 Cocoa 框架的指南。
* iOS 应用编程指南 介绍了用来开发运行 iOS 设备的应用程序的特定框架。

# 什么是Cocoa？

Cocoa 是一个在OS X操作系统以及iOS上的应用程序环境，操作系统是用在类似iPhone，iPad, 和 iPod touch等设备上的。它由一组面向对象的软件库，一个运行时系统，以及一个整合的开发环境组成。  
本章扩展了此定义，描述了 Cocoa 在两个平台上的目的、功能和组件。阅读Cocoa的功能描述对于Cocoa的开发人员来说是重要的第一步。  

## Cocoa环境

Cocoa是一套面向对象的框架，它为运行在OS X和iOS上的应用程序提供了运行时环境。Cocoa对于OS X是一个优秀的应用程序环境，但对于iOS来讲是唯一的应用环境。（Carbon是一个在OS X的替代环境，但它是一个可以与共存的框架）

### Cocoa简介

### Cocoa是如何适配OS X的

### Cocoa是如何适配iOS的

## Cocoa应用的功能

## 开发环境

### 平台SDKs

### 开发流程概览

### Xcode

### 界面编辑器

### iOS模拟器应用

### 性能应用和工具

## Cocoa框架

### Foundation

### AppKit (OS X)

### UIKit (iOS)

### AppKit和UIKit类对比

### Core Data

### 其他框架和Cocoa API

## 一点历史

# Cocoa对象

## 一个简单的Cocoa命令行工具

## OC面向对象编程

Cocoa中遍布面向对象，从其编程范式到其机制再到其事件驱动架构。OC，Cocoa的开发语言，也是彻底的面向对象，尽管其基础是ANSI C。它为消息分发和定义新的类并指定句法约定提供了运行时支持。OC支持其他编程语言类似C++和Java等的大部分的抽象和机制。这包括继承，封装，复用和多态。  
但OC与其他面向对象语言不同，尤其是在比较重要的地方。比如，OC不像C++，不允许运算符重载，模板或者多重继承。  
尽管OC没有这些功能，但它作为一个面向对象的编程语言是有所补偿的。下文继续探究OC的特殊功能。  

```
附加阅读：《OC编程语言》大部分章节的简介信息都可以作为OC语言的最佳指导，查阅该文档作为详情和OC的补充介绍。
```

### OC的优势

如果你是一个面向对象概念的新手程序员，首先把一个对象从根本上看作是一些功能的关联可能会比较有帮助。这一理解距离实际并不遥远，尤其是在运行时的实现中。  
每个OC对象都隐藏了其首个成员数据结构——或者实例变量——即isa指针。（大部分剩下的成员都由对象和其父类定义。）  isa指针，就如其名字所暗示的那样，指向对象的类，它本身是一个对象（参见图2-1），是从类定义编译的。类对象维护了一个调度表，该调度表基本上由指向它实现的方法的指针组成；它还指向其父类的指针，其父类页游其自己的调度表和父类指针。通过此引用链，对象可以访问它的类以及所有其父类所实现的方法（所有继承的公开和受保护的实例变量）。isa指针对于消息调度机制和Cocoa对象的动态性至关重要。  

图 2-1 一个对象的isa指针  
![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/ns_gadget.gif)  

对象外层所展现的内容是对OC运行时发生的情况的一个非常简化的视图，以启用消息调度、继承和常规对象行为的其他方面。但是这些信息对于理解OC的目标优势以及其动态性至关重要。  

### OC 的动态性

OC 是非常动态化的语言。它的动态性将程序从编译时和链接时的约束释放出来，并当用户可以控制时为符号化分析转移了大量功能到运行时。OC 比其他编程语言更加动态，因为它的动态性来自三个来源：  

* 动态类型——在运行时判断一个对象的类
* 动态绑定——在运行时判断调用的方法
* 动态加载——在运行时添加新的模块给程序

对于动态类型，OC 引入了 id 数据类型，它可以表示任意 Cocoa 对象。这种常见对象类型的使用展示在 清单2-2 中：  

	id word;
	while (word = [enm nextObject]) {
	    // do something with 'word' variable....
	}

id 数据类型可以在运行时代替任意类型的对象。因此，你可以让运行时因素决定代码中使用的对象类型。动态类型能够让对象在运行时进行关联而非强制在静态设计时被编码。编译时的静态类型检测可能会严格校验数据的完整性，但作为严格校验完整性的交换，动态类型给予了你的程序很大的灵活性。并随着对象的自省能力（比如查询一个动态类型，匿名该对象的类型）你可以在运行时校验该对象的类型，并在特定的操作中证实其适当性。（当然，你可以在你需要的时候始终使用静态检测该对象的类型。）  
动态类型为动态绑定提供了实质，OC 的第二个动态机制。就像动态类型将一个对象的类的从属关系推迟到了运行时才决定一样，动态绑定将该调用哪个方法推迟到了运行时才决定。方法调用在编译期间不绑定到代码；它们仅在实际消息传递时被绑定。由于同时拥有动态绑定和动态类型，你可以在每次执行代码时获得不同的结果。运行时因素决定哪个接收者被选择以及调用了哪个方法。  
运行时消息分发机制让动态绑定成为可能。当你发送一个消息给一个动态类型的对象时，运行时系统会使用接收者的isa指针定位对象的类型，然后从该类型中调用方法的实现。方法是动态绑定给消息的。并且你不需要在你的OC代码中做任何事就能够获取到动态绑定的好处。它在你发送一条消息时是例行公事和显在的发生的，尤其是给一个动态类型的对象发送消息时。  
动态加载，最后一个动态机制类型，是一个依赖于OC运行时支持的Cocoa功能。由于拥有动态加载，Cocoa程序能够在它们需要的时候加载可执行代码和资源，而不必在启动时就将所有的程序组件都载入。可执行代码（链接优先加载）通常包含成为整合到运行时程序镜像的新的类。无论是代码还是本地资源（包括nib文件）都会打包进bundle中，并显式加载到 Foundation的 NSBundle 类中定义的方法中。  
这种程序代码和资源的"延迟加载"通过降低对系统的内存要求来提高整体性能。更重要的是，动态加载使得应用程序变得可以扩展。你可以为你的应用程序设计一个插件架构，允许你或者其他的开发者定制额外的模块，以便让应用程序在数月甚至数年后发布时动态加载。如果设计正确，这些模块的类将不会与已经存在的类冲突，因为每个类封装其实现并拥有自己的命名空间。  

### OC的扩展性

OC 突出了四种扩展性，都是在软件开发领域非常有力的工具：分类，协议，声明属性和快速枚举。某些扩展为生命属性和将其关联类引入了不同的技术。其他的提供了便捷方法访问对象的属性，快速枚举集合，处理异常和执行其他任务。  

#### 分类

分类给予了你一种无需创建子类就能够给一个类添加方法的方式。分类中的方法会变成类类型的一部分（只限于你的程序中）并被所有该类的子类所继承。在运行时原方法和添加的方法没有区别。你可以发送一条消息给任意类（或其子类）的实例来调用在分类中定义的方法。  
分类不只是给一个类添加行为的便捷方式。你还可以使用分类来区分方法，分组相关的方法到不同的分类中。分类能够被灵活的用来处理组织大型的类；你甚至可以将不同的分类放到不同的源文件中，对于实例而言，可以有不同的开发者使用同一个类。  
声明和实现一个分类就像执行子类一样。从语法上，唯一的区别是分类的名称，它遵循@interface或@implementation指令，并放在括号中。举个例子，假设你想要添加一个NSArray 类的方法来以更结构化的方式打印该集合的信息的话。在分类的头文件中，编写类似以下声明的代码即可：  

	#import <Foundation/NSArray.h> // if Foundation not already imported
 
	@interface NSArray (PrettyPrintElements)
	- (NSString *)prettyPrintDescription;
	@end

然后在实现文件中你可以编写如下代码：  

	#import “PrettyPrintCategory.h”
 
	@implementation NSArray (PrettyPrintElements)
	- (NSString *)prettyPrintDescription {
	    // implementation code here...
	}
	@end

对于分类有一些限制。你不能使用分类来给该类添加任何新的实例变量。虽然一个分类方法能够重写一个已经存在的方法，但我们不推荐你这么做，尤其是你想要扩大当前的行为时。这种警告的其中一个原因是分类方法是类的头文件的一部分，所以没有一种方式是发送一个消息给super来获取已经被类定义的行为。如果你需要改变一个该类已经存在的方法的话，最好是声明一个该类的子类。  
你可以给根类NSObject定义分类添加方法。这些方法会对于所有链接到你的代码的实例以及类对象都可用。非正式协议——Cocoa代理机制的基础——就是声明为NSObject的分类的。不过，过度曝光对于其使用也是危险共存的。你通过分类添加到NSObject的每个对象都可能会遇到你事先没有预料到的问题，导致崩溃，数据污染，甚至更糟。  

#### 协议

OC的另一个扩展protocol非常像Java中的接口。都是直接把一系列方法声明在一个公开的接口中，其他类都可以选择实现。协议中的方法被某些其他类的实例对象发送的消息调用。  
协议的主要价值是它们很像分类，能够替代子类。它产生了在C++中的多重继承的优势，能够共享接口（如果没有实现）。接口也是一种让类声明一个接口时想要隐藏其身份的一种方式。接口可能会暴露一个类要提供的所有或者（通常来讲）一部分服务。整个类继承等级的其他类，不一定在任何继承关系（甚至不到根类），可以实现该协议的方法，因而访问已经公开的服务。使用协议，即使对另一个类的身份一无所知（即类的类型）也能够与该类以协议发布的特定目的进行通信。  
有两种类型的协议：正式和非正式。非正式协议在“协议”中简单提过。即NSObject的分类；因此，每个以NSObject作为其根类的对象（类对象也是）隐含的已经采用了在分类中公开的接口。要使用一个非正式协议，一个类不需要实现它其中声明的每个方法，只需要实现它想要实现的即可。至于非正式协议是如何工作的，类声明的非正式协议在给目标对象发送协议消息之前必须正确响应从一个目标对象发出的respondsToSelector: 方法消息。（如果目标对象没有实现方法，会有一个运行时异常。）  
正式协议在Cocoa中通常被设计为protocol。它让一个类正式的声明一系列的需要公开服务的接口。OC语言和运行时系统支持正式协议；编译器会检测基于协议的类型，对象可以在运行时进行内省来检验一个协议的一致性。正式协议有其自己的术语和语法。对于发布者和客户端术语有所不同：  

* 发布者（通常是一个类）声明正式协议。
* 客户端类采用一个正式协议，这样做既为同意实现所有协议中要求的方法。
* 如果一个类采用了或者继承了一个类采用的一个协议，那么类要遵循一个正式协议（协议是可以被子类继承的。）

在OC中，无论是声明还是遵循一个协议，都有其自己的语法格式。要声明一个协议，必须使用@protocol编译器指令。下例展示了 NSCoding 协议的声明（在Foundation框架的头文件NSObject.h中）。  

	@protocol NSCoding
	- (void)encodeWithCoder:(NSCoder *)aCoder;
	- (id)initWithCoder:(NSCoder *)aDecoder;
	@end

OC2.0版本通过基于你选择声明可选协议和必选协议方法来改进了正式协议。在OC1.0版本中，采用一个协议必须实现所有该协议的方法。在OC2.0中，协议方法默认必须，但可以指定@required指令作为标记。不过你也可以使用@optional指令标记协议方法作为可选实现；所有在此指令后声明的方法，除非中间遇到@required，都可以选择是否实现。看如下声明：  

	@protocol MyProtocol
	// implementation of this method is required implicitly
	- (void)requiredMethod;
	 
	@optional
	// implementation of these methods is optional
	- (void)anOptionalMethod;
	- (void)anotherOptionalMethod;
	 
	@required
	// implementation of this method is required
	- (void)anotherRequiredMethod;
	@end

声明协议方法的类通常不用实现这些方法；不过，应该在遵循协议的类的实例中调用这些方法。在调用可选方法之前，应该使用respondsToSelector:方法检查该方法是否被实现。  
通过指定协议，一个类可以采用一个协议，包裹在一个尖括号中，在其@interface指令的末尾，跟随其父类。一个类可以采用多个协议，通过逗号分隔即可。Foundation的NSData类是如何采用三个协议的：  

	@interface NSData : NSObject <NSCopying, NSMutableCopying, NSCoding>

采用了三个协议，NSData其本身实现了在这些协议中声明的所有必须实现的方法。还可以选择实现标记为@optional的可选方法。分类也可以采用协议，并且它们的采用也会变成其类的一部分。  
OC按照类遵循的协议以及其继承的类进行分类。你可以通过发送一个conformsToProtocol: 消息来判断一个类是否遵守了一个特定协议：  

	if ([anObject conformsToProtocol:@protocol(NSCoding)]) {
	        // do something appropriate
	}

在一种类型的声明中——一个方法，实例变量或者函数——你可以指定遵循协议作为该类型的一部分。你同样获取到了另一层编译器提供的类型检查机制，这更加抽象，因为它并没有绑定到某个指定的实现上。作为遵循协议，你可以使用同样的语法约定：将协议名放在尖括号指定该类型遵循的协议。通常会看到动态对象类型，id，用在这些声明当中，比如：  

	- (void)draggingEnded:(id <NSDraggingInfo>)sender;

在这里参数中提及的对象可以为任意类型，但它必须遵循 NSDraggingInfo 协议。  
Cocoa提供了很多种协议的示范，不止目前所展示的这些。一个比较有意思的是 NSObject 协议。毫无意外的，NSObject 类遵循它，但其他根类也是如此，比如NSProxy。通过该协议，NSProxy类可以与OC运行时各个部分进行交互，这些部分对于引用计数、内省和其他基本的对象行为都至关重要。  

#### 声明属性

在对象的模型设计模式中（参见“对象模式”）对象拥有属性。属性组成了一个对象的特性，比如作为一个标题和颜色，一个对象与另一个对象的关系。在传统OC代码中，通过声明一个实例变量来定义属性，并且为了强制封装，通过实现访问器方法来获取和设置这些变量的值。这是一个乏味且容易出错的任务，尤其当内存管理是一个问题的时候（参见“存储和访问属性”）。  
在OC2.0中，在OS X v10.5中已经引入，提供了一种语法来声明属性并指定它们该如何被访问。声明一个属性变为一种声明设置和获取方法的速记方式。使用属性，你不用必须实现存取方法。通过一个点语法直接访问属性值也是可以的。属性的语法有三个方面：声明，实现和访问。  
无论是在类，分类或者协议声明部分都可以声明属性。声明属性的语法是：  

	@property(attributes...)type propertyName

当attributes是一个或多个可选属性时（如果是多个的话用逗号分隔）会影响编译器如何存储实例变量以及合成存取器方法。type元素指定一个元素的类型，声明类型或者标准类型，比如id, NSString *, NSRange, 或者 float。属性必须由一个同样类型和名称的实例变量支持。  
在属性中可选的attributes声明在列表2-1中。  

列表2-1 可以用来声明在属性中的attributes 

属性  | 效果
------------- | -------------
getter=getterName，setter=setterName  | 指定getter和setter存取器方法的名称（参见“存储和访问属性”）。当你实现你自己的存取方法并想要控制其名称时你可以指定这些属性。
readonly | 标明属性只能被读取，不能被写入。编译器不会合成setter存取方法或者允许一个非同步的方法调用。
readwrite | 标明属性能够被读写。若readonly没有指定，默认为此。
assign | 指定在实现setter方法时只需要实现赋值；这为默认。如果是声明在非垃圾回收的程序中，必须指定对象属性为retain或者copy。
retain | 指定在赋值前，retain应该发送给属性（必须为对象类型）。注意retain在垃圾自动回收环境中禁用retain。
copy | 指定在赋值前，retain应该发送给属性（必须为对象类型）。对象的类必须实现了NSCopying协议。
nonatomic | 指定存取方法合成为非原子化的方法。默认的，所有的存取方法都是原子化的：getter方法保证返回一个有效值，即使是在其他线程同时在执行。有关原子化和非原子化的属性的相关讨论，尤其是和性能相关的部分，参见《OC编程语言》的“声明属性”部分。  
如果你没指定属性并在实现中指定类@synthesize，编译器会直接使用赋值以及以propertyName作为getter setPropertyName: 作为setter名称合成属性的getter和setter方法。  
在一个类的定义的 @implementation 块中，你可以使用 @dynamic 和 @synthesize 指令直接控制编译器对于某个属性合成存取方法。两个指令有同样的语法：  

	@dynamic propertyName [, propertyName2...];
	@synthesize propertyName [, propertyName2...];

@dynamic指令会告诉编译器你要自己为属性实现存取方法，无论是直接或者动态的（比如在动态加载代码时）。另一方面@synthesize指令告诉编译器如果存取方法没有在@implementation块中，那么就去合成存取方法。@synthesize的语法同样包含一个扩展能够让你使用不同的名称来给属性和其实例变量存储。看下如下语句：  

	@synthesize title, directReports, role = jobDescrip;

这会告诉计算机给title, directReports, 和 role合成存取方法，并使用jobDescrip实例变量返回role属性。  
最后，OC属性功能通过使用点语法和直接赋值对于存取属性支持一个简化的语法。下例展示了如何简单的使用并获取属性的值以及使用该语法对其进行设置：  

	NSString *title = employee.title; // assigns employee title to local variable
	employee.ID = "A542309"; // assigns literal string to employee ID
	// gets last name of this employee's manager
	NSString *lname = employee.manager.lastName;
	
注意点语法只在属性和简单的一对一关系中才有用，对于一对多的关系无用。  

```
扩展阅读：要更多的了解声明属性，阅读《OC编程语言》中的“声明属性”部分。
```

#### 快速枚举

快速枚举是OC2.0中引入的一项语言功能，它为你枚举一个集合提供了简单的语法。也比使用传统的 NSEnumerator 对象迭代数组、集合和字典更快。此外，它通过包含一个突变保护防止在枚举过程中修改集合，确保安全枚举。（如果尝试突变，则会抛出异常。）  
快速枚举的语法与在类似Perl和Ruby这种脚本语言中的类似；支持两个版本：  

	for ( type newVariable in expression ) { statements }

和

	type existingVariable;
	for( existingVariable in expression ) { statements }
	
expression必须必须是一个遵循NSFastEnumeration 协议的类。快速枚举的实现在OC运行时和Foundation框架中共享。Foundation框架声明了NSFastEnumeration协议，Foundation的集合类——NSArray, NSDictionary, 和 NSSet——和NSEnumerator类都采用的这一协议。其他类会持有其他对象的集合，包括自定义类也可以采用NSFastEnumeration协议来利用这一功能。  
下列代码块展示了你可以使用快速枚举在NSArray 和 NSSet 对象上：  
 
	NSArray *array = [NSArray arrayWithObjects:
	        @"One", @"Two", @"Three", @"Four", nil];
	 
	for (NSString *element in array) {
	    NSLog(@"element: %@", element);
	}
	 
	NSSet *set = [NSSet setWithObjects:
	        @"Alpha", @"Beta", @"Gamma", @"Delta", nil];
	 
	NSString *setElement;
	for (setElement in set) {
	    NSLog(@"element: %@", setElement);
	}

```
扩展阅读：要了解更多关于快速枚举，包括一个自定义集合类该如何利用这一功能，参见《OC编程语言》中的“快速枚举”一节。
```

### 使用OC

在面向对象的程序中，是通过消息来完成工作的；一个对象给另一个对象发送消息。通过消息，发送对象从接收对象请求某事。它请求接收方执行某个动作，返回某个对象或者值，或者两种都有。  
OC为消息采用了一种独特的语法。下面的语句是在SimpleCocoaTool代码中的，清单2-2:  

	NSEnumerator *enm = [sorted_args objectEnumerator];

消息表达式是在语句的右边，被方括号包裹。消息的最左方是接收者，一个变量或者表达式表示是该对象发送的消息。在这个示例中，接收者是sorted_args，一个NSArray类的实例。跟着接收者的是消息本身，在本例中是objectEnumerator。（现在，讨论只聚焦在消息语法而非深入了解这到底是什么以及SimpleCocoaTool中的其他消息到底做了什么。）消息objectEnumerator调用了sorted_args对象的一个叫做objectEnumerator的方法，它会返回一个对象的引用，该引用会被语句左边的enm变量持有。这个变量作为 NSEnumerator 类的实例静态类型。你可以用图表表达这个语句：  

	NSClassName *variable = [receiver message];

不过，这种图表是简化的并且不精确。一条消息是由一个消息名和消息的参数组成。OC运行时使用了消息名，类似上面的objectEnumerator，要在一个列表当中查找到一个消息名，然后调用。消息名是唯一的身份认证，它代表了一个方法并拥有一个特殊的类型，SEL。由于这密切相关，用于查找消息的消息名也经常作为消息。上述语句更正确的展示如下：  

	NSClassName *variable = [receiver selector];

消息通常都有参数，一般叫做arguments。一条消息有一个参数的要在消息名后加一个冒号，然后跟着参数名。这种结构叫做一个keyword；一个keyword末尾跟着一个冒号，然后一个参数在冒号后。因此我们展示一条带有一个参数的消息表达式如下：  

	NSClassName *variable = [receiver keyword:parameter];

如果一条消息有多个参数，消息名就有多个关键字。一个消息名包含所有的关键字，包括冒号，但不包括其他内容，比如返回值或者参数类型。一条含有多个关键字的消息表达式（加上赋值）展示如下：  

	NSClassName *variable = [receiver keyword1:param1 keyword2:param2];

由于有函数参数，一个参数的类型必须与方法声明中指定的类型匹配。看下SimpleCocoaTool中的如下消息表达式：  

	NSCountedSet *cset = [[NSCountedSet alloc] initWithArray:param];

这里的param，也是一个NSArray类的实例，它是叫做initWithArray:的消息的参数。  
上述引用的initWithArray:展示了嵌套。你可以将一条消息嵌套在另一条消息当中；由一条消息表达式返回的对象被包围它的消息表达用作接收者。所以要解释嵌套消息表达式，从内部表达式向外操作。上述语句的解释如下：  

1. alloc 消息发送给 NSCountedSet 类，这会创建一个未初始化的类的实例（给其分配了内存空间）。
	```
	注意：OC的类是对象，在其右边你可以给它发送消息，也个可以给其实例发送消息。在一条消息表达式中，一个类消息的接收者始终是一个类对象。
	```
2. initWithArray:消息发送给未初始化的实例，它会用数组args将其初始化，然后返回它自身的一个引用。
	
SimpleCocoaTool的main函数中的语句中下一个需要注意的是：  

	NSArray *sorted_args = [[cset allObjects] sortedArrayUsingSelector:@selector(compare:)];

这条消息表达式显著的特征是sortedArrayUsingSelector:的参数。这个参数需要使用@selector编译器指令来创建一个消息名当作一个参数。  
我们先暂停重新看下消息和方法的术语。方法本质上是由消息接收者为成员的类定义和实现的函数。消息是一个消息名（可能有一个或多个关键字组成）和参数；一条消息发送给接收者以及它的结果在方法的调用中（或者执行）。一条消息表达式包括接收者和消息。图2-2描述了这些关系。  

图2-2 消息术语  

![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/message_terms.jpg)

OC会使用一些在ANSI C中没有的定义类型和字面量。在某些情况下，这些类型和字面量会替代其ANSI C的对应部分。列表2-2描述了一些重要的，包括每种类型的可用字面量。  

列表2-2 部分OC定义的类型和字面量  

类型  | 描述和字面量
------------- | -------------
id  | 动态对象类型。它的否定是nil。
Class  | 动态类类型，它的否定是Nil。
SEL  | 一个选择器的数据类型（typedef）。该类型的否定是NULL。
BOOL  | 一个布尔类型。它的字面值是YES和NO。

在你的程序的控制流语句中，你可以判断一个适当的负数字面量是否存在（或者不存在）来决定如何执行。举个例子，以下SimpleCocoaTool 代码中的 while语句隐式的判断了word对象变量是否是一个返回对象（或者在其他的情况下，不存在的为nil）：  

	while (word = [enm nextObject]) {
	    printf("%s\n", [word UTF8String]);
	}

在OC中，你经常可以发送一个消息给nil，这不会有任何负面影响。只要返回的类型被视作一个对象，则从发送到nil的消息的返回值就保证有效。参见《OC编程语言》中的“给nil发送消息”部分了解详情。  
最后一个SimpleCocoaTool代码中需要注意的是，如果你是OC的新手，那么这些代码就不容易显现出来。看下这条语句：  

	NSEnumerator *enm = [sorted_args objectEnumerator];

和这一条：  

	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];

从表面来看，它们看起来完全相同；都返回了一个引用给对象。不过在语义上有一个重要的不同（对于内存管理的代码）是是否对于返回对象有关，因此是否需要释放它。在第一条语句中，SimpleCocoaTool 程序没有它自己的返回值。在第二条语句中，程序创建了对象并拥有它。程序做的最后一件事是发送 release 消息给创建的对象，从而释放它。另一个显式创建的对象（NSCountedSet实例）也显式的在程序结束时释放了。对于对象拥有关系和释放的内存策略的详情，以及方法使用这种策略的详情，参见“内存管理是如何工作的”。

## 根类

仅凭OC语言和运行时是不能够构建哪怕最简单的面向对象程序的，至少没那么简单。还是缺了一些东西：一个定义基本行为和对于所有对象都适用的接口。一个根类支持这种定义。  
之所以叫根类因为它是累的继承链的根部——这里指Cocoa的类继承链。根类不继承任何其他类，其他所有类最终都是继承于此。与OC一样，根类主要是Cocoa直接访问以及与OC运行时交互的地方。Cocoa对象在很大程度上从根类中获得作为对象的能力。  
Cocoa支持两个根类：NSObject 和 NSProxy。Cocoa定义了后者，一个抽象的超类，它作为一个对象，以及其他对象的替身；因此NSProxy在分布式对象结构中至关重要。由于这一特殊角色。NSProxy很少出现在Cocoa程序中。当Cocoa开发者提到根类或者基础类时，他们几乎总是指的NSObject。  
本段落我们会看下NSObject，它是如何在运行时进行交互的，以及它为所有Cocoa对象定义的基本的行为和接口。由其是讨论了NSObject的声明的分配内存，初始化，内存管理，内省和运行时支持的各种方法。这些概念对于理解Cocoa是一个基础。  

### NSObject

NSObject是大部分OC类继承链的根类；它没有父类。其他类从NSObject继承了OC语言的基本接口和运行时系统，它们的实例才有了作为一个对象的能力。  
虽然严格来说并非一个抽象类，但NSObject是一个虚拟的。作为一个简单的对象，NSObject的实例不能够做任何有用的事。要添加任何属性和逻辑给你的程序，你必须创建一个或多个继承自NSObject的类或者其他的从NSObject衍生出的类。  
NSObject采用了NSObject协议（参见根类——和协议）。NSObject协议允许多个根对象。比如，NSProxy是另一个根类，并不继承自NSObject，但采用了NSObject协议，以便它可以与其他OC对象公用一个共同的接口。  

### 根类——和协议

NSObject不仅是一个类的名字，而且是一个协议名。这两样定义了Cocoa中的对象。NSObject协议为所有在Cocoa中的根类的需要指定了基本编程接口。因此不仅NSObject类采用了同样名称的类，其他的Cocoa根类NSProxy也采用了。NSObject类更指定了任何Cocoa对象并非一个代理对象的基本接口。  
OC的设计在所有Cocoa对象的定义中使用了一个类似NSObject的协议（而非让协议的方法作为类接口的一部分）来让多个根类成为可能。每个根类共享一个公用接口，被它们所采纳的协议所定义。  
在另一种情况下，NSObject不仅是根协议。虽然NSObject类并不正式遵循NSCopying, NSMutableCopying, 和 NSCoding 等协议，但它声明并实现了与这些协议相关的方法。（此外，NSObject.h头文件也包含了NSObject类的定义并包含了NSObject根协议的定义，以及NSCopying, NSMutableCopying, 和 NSCoding。）对象的拷贝，编码，以及解码也是对象行为的基础部分。许多子类（如果不是大多数）预计会采用或遵守这些协议。  

```
注意：其他Cocoa类能够通过分类给NSObject添加方法，这些分类通常在代理中使用非正式协议；它们允许代理选择分类的方法来实现。不过，这些NSObject的分类不会被作为对象接口的基础的一部分。
```

### 根类方法概览

NSObject根类，和采用NSObject协议以及其他根协议，为所有非转发Cocoa对象指定了一下接口和行为角色：  

* 分配内存，初始化和副本。某些NSObject的方法（包括一些采用的协议）处理了创建，初始化和对象的副本：  
	* alloc 和 allocWithZone: 方法会从内存区域给一个对象分配内存并设置对象指向其运行时类的定义。
	* init 方法是对象初始化的原型，程序是将一个对象的实例变量设置为一个一直的初始值。类方法initialize 和 load 给予类一个机会来初始化它们自己。
	* new 方法是一个简便方法，它将分配内存和初始化结合了起来。
	* copy 和 copyWithZone: 会将任意类的成员（实现了NSCopying协议的方法）进行拷贝；mutableCopy 和 mutableCopyWithZone:   （NSMutableCopying协议中定义）实现了对象的可变拷贝。  
参见“对象的创建”了解详情。
* 对象的持有和销毁。以下方法在使用传统的显式的内存管理的面向对象程序中尤其重要：  
	* retain 方法会让一个对象的引用计数增加。
	* release 方法会让一个对象的引用计数减少。
	* autorelease 方法也会减少一个对象的引用计数，但是是延迟改变。
	* retainCount 方法返回一个对象当前的引用计数。
	* dealloc 方法被一个类实现用来释放器对象的实例变量以及释放动态分配的内存。  
参见“内存管理是如何工作的”了解更多关于显式内存管理的详情。

* 内省和比较。很多NSObject的方法能够让你在运行时检索一个对象。这些内省方法能够帮助用来发现一个对象在类继承链中的位置，判断它是否实现了某个方法，检测它是否遵循了某个特定协议。这些当中有的只是类方法。  
	* superclass 和 class 方法（类和实例）分别返回接收者的父类和类，是一个Class对象。
	* 你还可以通过isKindOfClass: 和 isMemberOfClass:方法判断对象的类的关系，后者用来判断接收者是否是一个指定类的实例。类方法isSubclassOfClass:判断类的继承性。
	* respondsToSelector:方法判断接收者是否实现了一个选择器识别的方法。类方法instancesRespondToSelector: 判断一个给定类的实例是否实现了指定方法。
	* conformsToProtocol: 方法判断接收者（对象或类）是否遵循一个给定协议。
	*  isEqual: 和 hash 方法用在对象的比较中。
	*  description 方法让一个对象返回一个字符串描述它的内容；这个输出通常用在调试中（打印对象命令）并在格式化字符串中以%@作为对象描述符。  
参见“内省”了解更多信息。  

* 对象的编码和解码。以下方法可用于对象的编解码（作为归档过程的一部分）：  
	*  encodeWithCoder: 和 initWithCoder: 方法是NSCoding协议的唯一成员。第一个方法让对象能够编码其实例变量，第二个方法让一个对象能够从解码实例变量初始化其本身。
	*  NSObject 类定义了其他有关对象编码的方法：classForCoder, replacementObjectForCoder:, 和 awakeAfterUsingCoder:。  
参见《归档和序列化编程指南》进一步了解。  

* 消息转发。forwardInvocation: 方法和关联方法能够让一个对象转发一条消息给另一个对象。
* 消息分发。一些以performSelector开头的方法能够让你在指定的延迟后分发消息，并从子线程到主线程发送消息（同步或异步）。

NSObject 还有一些其他的方法，包括用于版本和乔装的类方法（后者允许一个类以另一个类的形式呈现在运行时）。它还包括允许你访问运行时数据结构的方法，比如方法选择器和方法实现的函数指针。

### 接口约定

一些NSObject的方法仅仅是要被调用的，而另一些是被设计用来重写的。比如，大部分子类都不应该重写allocWithZone:，但都应该实现init——或者至少是一个初始化方法，该方法最终会调用根类的init（参见“对象的创建”）。这些方法是希望被子类重写的，NSObject实现这些方法要么是什么都没做，要么就是返回了某些合理的默认值，比如self。这些默认的实现使得发送基本的类似init给任何Cocoa对象成为可能——甚至是给一个没有重写这些方法的类的对象——并且也不会造成运行时异常。在发送消息之前也没有必要进行检查（使用respondsToSelector:）。更重要的是，NSObject的“占位”方法为Cocoa对象定义了一个通用架构，并创建了这一惯例，当所有的类都遵守时，这让对象的交互更加可靠。  

### 实例和类方法

运行时系统对定义在根类中的方法是特殊对待的。根类中定义的实例方法能够被实例和类对象执行。所以，所有的类对象都可以访问定义在根类中的实例方法。任何类对象都可以执行任何实例方法，前提是它没有具有相同名称的类方法。  
比如，一个类对象能够发送消息来执行NSObject实例方法respondsToSelector:和performSelector:withObject: 如下所示：  

	SEL method = @selector(riskAll:);
 
	if ([MyClass respondsToSelector:method])
	    [MyClass performSelector:method withObject:self];

注意只有定义在根类中的实例方法对于类对象才可用。在上例中，如果MyClass重新实现了respondsToSelector: 或者 performSelector:withObject:，这些新版本的方法只有对于实例对象可用。MyClass的类对象只能执行定义在NSObject类当中的版本。（当然，如果MyClass实现了respondsToSelector: 或 performSelector:withObject: 作为类方法，而非实例方法，该类也能够执行这些新版本。）

## 对象的持有和释放

OC给予你两种方式来确定对象在被需要的时候存在以及当不被需要的时候销毁，从而释放内存。我们推荐使用垃圾回收技术：运行时会检测对象不再被需要并自动释放它们。（推荐的方式在大部分情况下都很容易实现。）第二种方式叫做内存管理，基于引用计数：一个对象会承载一个数字值，嗲表当前的持有数；当这个值为0的时候，对象被释放。  
作为一个开发者在编写OC代码时，你利用垃圾回收或者内存管理而必须完成的工作量差别很大。  

* 垃圾回收。要开启垃圾回收，你需要在Xcode中开启OC垃圾回收构建选项（-fobjc-gc 标记）。对于你自定义的类，你还需要实现 finalize 方法来移除作为通知中心的实例并释放非实例变量的任何资源。同样，你应该确保你的nib文件对象作为文件的拥有者持有一个接口连接到每个你想要保存的顶层nib对象。  
```
iOS注意：垃圾回收不支持iOS
```
* 内存管理。在内存管理代码中，每个对对象进行所有权要求的叫做——对象分配和初始化，对象拷贝和持有——必须匹配调用移除该呼叫——释放和自动释放。当对象的引用计数（反应其被引用的次数）到0的时候，对象会释放，并且被对象占用的内存也会释放。

### 垃圾回收是如何工作的

### 内存管理是如何工作的

## 对象的创建

### 分配内存给对象

### 初始化一个对象

#### 初始化的格式

#### 初始化的问题

#### 实现一个初始化方法

#### 多个初始化和指定初始化

#### dealloc 和 finalize 方法

#### 类工厂方法

## 内省

内省是一个面向对象语言和环境的强有力的工具，OC和Cocoa中的内省也不例外。内省指的是在运行时对象暴露其作为对象本身的信息的一种能力。这种信息包括对象在其继承链中的位置，它是否遵循某个特定协议，它是否响应某个消息。NSObject 协议和类定义了很多内省方法，你可以用来在运行时查询对象的特性。   
使用得当的话，内省会让面向对象程序更加高效和健壮。它能够帮助你避免消息分发的错误，对象相等性的错误假设以及类似的问题。以下章节展示了你该如何在你的代码中高效使用NSObject的内省方法。  

### 评估继承关系

一旦你知道了一个对象的所属的类，你应该对于对象有了一定的了解。你可能会知道其功能，它所代表的属性，以及它能够接收什么样的消息。即使在内省之后你依旧对于一个对象所属的类不够熟悉，你也至少知道不要给它发送什么消息了。  
NSObject协议声明了一些方法来判断一个对象在类的继承链中的位置。这些方法是以不同的时间粒度操作的。比如，class和superclass实例方法返回的Class对象分别代表接收者的类和父类。这些方法需要你用一个Class对象和另一个进行比较。清单2-7给出了一个简单的（也可以说是不太重要）的使用示例。  

清单2-7 使用类和父类方法  

	// ...
	while ( id anObject = [objectEnumerator nextObject] ) {
	    if ( [self class] == [anObject superclass] ) {
	        // do something appropriate...
	    }
	}

```
注意：有时候你使用class或者superclass方法来为一个类消息获取一个恰当的接收者。
```

更常见的，检查一个对象的从属关系，可以发送一条isKindOfClass: 或 isMemberOfClass: 消息。前者会返回接收者是否是一个给定类的实例或者是任意从该类继承的类的实例。另一方面，isMemberOfClass: 会告诉你接收者是否是一个指定类的实例。isKindOfClass: 方法更加常用，因为你可以通过它立刻获取你给一个对象发消息的完整范围。看下清单2-8中的代码块。  

清单2-8 使用isKindOfClass:  

	if ([item isKindOfClass:[NSData class]]) {
	    const unsigned char *bytes = [item bytes];
	    unsigned int length = [item length];
	    // ...
	}

通过了解到对象item继承自 NSData 类，这段代码知道了它能够发送NSData 的bytes 和 length 消息。如果你假设item是一个NSMutableData 的实例的话，那么isKindOfClass: 和 isMemberOfClass: 的区别就很显然了。如果你使用isMemberOfClass: 代替 isKindOfClass:，条件语句中的代码就不会被执行了，因为item并非是NSData的实例，而是NSMutableData的，它是NSData的子类。

### 方法的实现和协议的一致性

另外两个NSObject更有用的方法是respondsToSelector: 和 conformsToProtocol:。这些方法会分别告诉你一个对象是否实现了某个方法以及一个对象是否遵循了一个特定的正式协议（意思是采用了协议，如果需要的话，实现了协议中所有的方法）。  
在你的代码中类似的情况下使用这些方法。它们让你能够在发送消息之前发现某些潜在的匿名对象可以适当的响应一个特定的消息，或者一组消息。通过在发送消息之前做这些检测，你能够避免产生运行时的不可识别的消息的异常。AppKit 框架实现了这些非正式协议——基于代理——通过在调用那个方法之前检测代理是否实现了这个代理方法（使用respondsToSelector: ）。  
清单2-9展示了在你的代码中该如何使用respondsToSelector:方法。  

清单2-9 使用respondsToSelector:  

	- (void)doCommandBySelector:(SEL)aSelector {
	    if ([self respondsToSelector:aSelector]) {
	        [self performSelector:aSelector withObject:nil];
	    } else {
	        [_client doCommandBySelector:aSelector];
	    }
	}

清单2-10 展示了在你的代码中该如何使用 conformsToProtocol:方法。  

清单2-10 使用conformsToProtocol:  

	// ...
	if (!([((id)testObject) conformsToProtocol:@protocol(NSMenuItem)])) {
	    NSLog(@"Custom MenuItem, '%@', not loaded; it must conform to the
	        'NSMenuItem' protocol.\n", [testObject class]);
	    [testObject release];
	    testObject = nil;
	}

### 对象的比较

虽然严格来讲hash 和 isEqual:并不是严格的内省方法，但它们都履行了类似的指责。在运行时它们是不可或缺的验证和比较对象的工具。但它并非在运行时检索关于一个对象的信息，而是依赖于特定类的比较逻辑。  
hash 和 isEqual: 方法都是声明在NSObject 协议中的，并且密切相关。hash方法实现的时候必须返回一个整数用作哈希表结构的表地址。如果两个对象相等（由isEqual:方法判断），它们必须有同样的哈希值。如果你的对象能够被类似NSSet这样的集合包含，你需要定义hash方法并验证如果两个对象相等，则它们返回相等的哈希值。NSObject中isEqual:的默认实现是直接检查指针是否相等。  
使用 isEqual: 方法很简单；它会比较接收者与作为参数提供的对象进行比较。对象比较经常为运行时应该如何处理对象提供信息。在清单2-11中展示了使用isEqual: 来判断是否执行一个动作，在这种情况下，保存已经修改的用户首选项。  

清单2-11 使用isEqual:  

	- (void)saveDefaults {
	    NSDictionary *prefs = [self preferences];
	    if (![origValues isEqual:prefs])
	        [Preferences savePreferencesToDefaults:prefs];
	}

如果你创建了一个子类，你可能需要重载isEqual:并为指针是否相等添加进一步的检查。子类可能定义了额外的属性，如果两个实例要判定为相等那么属性也应该相等。比如，假设你创建了一个NSObject 的子类叫做 MyWidget，它包括两个实例变量name 和 data。这两个变量必须都相等，两个MyWidget的实例才会被视作相等。清单2-12 展示了MyWidget 的isEqual:实现。   

清单2-12 重载isEqual:  

	- (BOOL)isEqual:(id)other {
	    if (other == self)
	        return YES;
	    if (!other || ![other isKindOfClass:[self class]])
	        return NO;
	    return [self isEqualToWidget:other];
	}
	 
	- (BOOL)isEqualToWidget:(MyWidget *)aWidget {
	    if (self == aWidget)
	        return YES;
	    if (![(id)[self name] isEqual:[aWidget name]])
	        return NO;
	    if (![[self data] isEqualToData:[aWidget data]])
	        return NO;
	    return YES;
	}

isEqual:方法首先检查指针是否相等，然后是类是否相等，最终调用一个对象的比较方法，其名称表示参与比较的对象类别。这种类型的比较方法会强制检测传入的对象，这在Cocoa中是惯例；NSString的 isEqualToString: 方法以及NSTimeZone 类的isEqualToTimeZone: 方法就是两个例子。类特定的比较方法——在本例中是 isEqualToWidget: ——执行名称和数据是否相等的检查。  
在所有的Cocoa 框架中的 isEqualTo类型：的方法中，nil不是一个有效的参数并且实现这些方法时可能会产生接收到nil的异常。不过，对于向后兼容，Cocoa 框架的 isEqual: 是可以接受nil的，它会返回nil。

## 对象的可变

## 类簇

## 桥接

## 创建一个单例

# 给一个Cocoa程序添加行为

## 起步

### 在main函数中发生了什么

## 使用Cocoa框架

### 类似框架的类

### Cocoa API 惯例

## 从Cocoa类继承

### 何时该重载一个方法

#### 调用还是重载？

#### 重载方法的类型

#### 何时该创建子类

就像知晓哪个类的方法该重载一样重要——并在这一决定之前就确定好——判断哪些类应该继承也同样重要。有的时候这些决定会很明显，有的时候远没有那么简单。一些设计的考虑能够帮助你做出选择。  
首先，知晓框架。你应该熟悉框架中的每个类的目的和能力。可能已经存在一个类做了你想要做的事。并且如果你找到了一个几乎做了你想要做的事的类的话，那你就走运了。该类就可以作为你的自定义类的父类。子类化是一个重用一个已经存在的类并为你的需求制定的过程。某些时候一个子类所有需要做的事情只是重载一个单一的继承来的方法，并将方法稍微做一些和原来的行为不同的改动而已。其他的子类可能需要添加一个或两个属性给其父类（作为实例变量），然后定义方法访问和操作这些属性，整合它们到父类的行为中。  
还有其他的考虑可以帮助你决定你的子类如何在类的结构中最好的存在。应用程序的性质是什么，或者说应用程序试图承载的部分是什么？某些Cocoa架构强加了它们自己的子类的要求。比如，如果你是一款在OS X上的多文档处理程序，被AppKit定义的基于文档的架构需要你继承自NSDocument和其他的类似的类。让你的Mac应用能够编写脚本（意思是需要编写AppleScript命令），你可能需要子类化AppKit中的一个脚本类，比如NSScriptCommand。  
其他因素是  

```
iOS 注意：AppKit框架的控制器类，包括NSController，在UIKit中并没有对应的。在UIKit中有控制器类——UIViewController, UITableViewController, UINavigationController, 和 UITabBarController——但是这些类是基于一种不同的设计，并有不同的目的——应用程序导航和模式选择（参见UIKit中的视图控制器部分了解详情）。
```

# Cocoa设计模式

很多Cocoa环境中的架构和机制都高效利用了设计模式：抽象设计是为了解决在特定环境中重复出现的问题。本章描述了Cocoa中设计模式的主要实现，聚焦于MVC和对象模型。本章主要的目的是让你更多的了解Cocoa中的设计模式，并鼓励你在你自己的工程中利用这些模式。  

## 什么是设计模式？

设计模式是一种解决在特定环境中通用、重复出现的问题的模板。它是一种抽象工具，用在类似架构和工程等软件开发领域。后续章节介绍了设计模式是什么，阐释了它们为什么对于面向对象设计非常重要，并展示了设计模式的示例。  

### 在环境中的问题解决方案

作为一名开发者，你可能已经对于面向对象编程中的设计模式的概念很熟悉了。它首先被权威描述并编写在《设计模式：可重复使用的面向对象软件的元素——Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides 》（通常称作“GOF”）该书出版于1994年，随后又出版了其他书记和文章进一步探索和阐述了面向对象的系统的设计模式。  
设计模式的简单定义是“一种在上下文中解决问题的方案。”让我们通过短语向后工作来分析这一点。上下文是模式适用的反复出现的情况。问题是你试图在此上下文中实现的目标，以及上下文中附带的限制。解决方案就是你所追求的：实现目标并解决限制的上下文的总体设计。  
设计模式抽象了结构设计的关键部分，并通过时间证明是有效的。模式是有一个名称并标识参与该模式的类和对象及其职责和协作。它还阐述了效果（收益）和在模式能够被应用的位置。设计模式对于一个特定设计是一种模板或者指南；从某种意义上来说，具体设计是一种模式的“实例化”。设计模式不是绝对的。在你应用它的时候你是拥有一定灵活性的，并且编程语言和现有框架通常可以确定如何应用该模式。  
很多设计的主题或原则影响了设计模式。这些设计原则是构建面向对象系统的经验法则，例如“封装不同系统结构的各个方面”和“与接口程序交互，而非实现”。这表达了很重要的观点。比如，如果你将系统的变化的部分分离出来，并对其封装，它就能独立于系统的其他部分，尤其是如果你为其定义接口并不与其指定实现关联的时候。随后你就可以对这些可变部分进行替换或者扩展，而不用影响系统的其他部分。因此消除了依赖，降低了耦合并让系统变得更灵活和容易变更。  
类似这样的收益使得当你编写软件的时候设计模式变为了一个重要的考虑因素。如果你查找，适配并将模式应用到你的程序设计中，那么该程序——由对象和类组成——将会可重用性更高，更容易扩展并在功能需要改变的时候更容易变更。此外，基于这样的设计模式的程序通常也会比没有基于这种设计模式的程序更简洁和高效，即需要更少的代码就能完成同样的功能。  

### 一个例子：命令行模式

大部分GOF的数据都由一个设计模式的目录组成。它通过将设计模式以适用范围（类或对象）或者目的（创建，结构或行为）的方式进行分类。每个在目录中的条目都讨论了设计模式的意图，动机，可用性，结构，参与者，协作性，结果和其实现。其中一个是命令行模式（一种对象行为模式）。  
该书陈述了命令行模式作为“讲一个请求封装为对象，从而让你参数化不同的请求为委托，队列或者日志请求，并支持可撤销操作。”的意图。该模式将能够接收和评估消息的对象分离为一个发送消息的对象。消息的发起者（客户端/委托）通过绑定一个或多个动作到一个指定接收者来封装请求。被封装的消息能够在对象之间进行传递，放到队列中或者存储到随后调用，并能够动态修改不同的接收者或者消息参数。图4-1展示了该模式的结构图。  

图4-1 命令行模式的结构图  

![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/command_pattern.gif)  

对于熟悉Cocoa的开发者而言，这种对命令行模式的剪短概述可能会敲响警钟。这种模式完美的描述了在Foundation框架中的类：NSInvocation，它的目的是封装消息。作为模式的意图所指出的，其中一个目的是让其能够执行撤销操作。Invocation对象用在Cocoa设计中的撤销管理和分布式对象，这也是一种进程间通信的架构。命令行模式同样描述了（虽然没那么完美）Cocoa的目标-动作机制，它用在用户界面的控制对象中，用来封装用户激活组件时的目标和动作消息。  
Cocoa在其框架和语言以及运行时中已经为你实现了很多目录中的设计模式。（这些实现在“Cocoa是如何适配设计模式的”中有相关描述。）你可以使用这些“现成”的设计模式适配来满足你的许多开发需求。或者根据你自己的需要判断你的问题并结合上下文声明一个全新的设计模式。最重要的是当你开发软件和设计时要在适当的时机使用模式。  

## Cocoa 是如何适配设计模式的

在 Cocoa 中你到处都可以看到设计模式，无论是 iOS 还是 OS X 当中。基于模式的机制和架构在 Cocoa 框架和 OC 运行时和语言当中很常见。Cocoa 通常把它自己独特的旋转放到图案上，因为它的设计受到类似语言能力或现有架构等因素的影响。   
本段包含了大部分在《设计模式：面向对象软件中的可重用元素》中的设计模式的概述。每段不仅概述类模式，而且还讨论了 Cocoa 对其的实现。Cocoa 实现的都已经列出，后续展示的每个模式的描述都属于一个特定的 Cocoa 上下文。  
Cocoa 实现设计模式是多种形式的。以下章节中描述的一些模式——比如协议和分类——是 OC 语言的功能。在其他情况下“模式的实例”是被一个或一组相关类所实现的（比如，类簇和单例）。其他的情况下，模式适配是一种主要的框架结构，比如响应者链条。某些基于模式的机制你几乎不用做什么，而其他的一些可能需要你参与一部分工作。即使是Cocoa 没有实现的模式，我们也建议你在情况适当的时候自己实现；比如，对象的复合（装饰模式）通常是一个比子类化已经存在的类更好的技术。  
随后的章节有两个设计模式，MVC和对象模态化。MVC是一个复合的或者说是综合的模式，这意味着它是基于几个模式。对象模态化在 GOF 中并没有对应的内容，而是源于关系数据库领域。而MVC和对象模态化可能是Cocoa中最重要也随处可见的设计模式了，并且很大程度上它们是相关联的模式。在某些技术的设计当中它们扮演着至关重要的角色，包括绑定，撤销操作，脚本和文档架构等。要了解更多关于这两个模式，参见“MVC设计模式”和“对象模态化”章节。

### 抽象工厂模式

抽象工厂设计模式提供了一种接口来创建类似相关或互相依赖的对象，而无需指定其具体的类。客户端从工厂获得的具体对象将和任何细节脱钩。  

#### 类簇

类簇是一种将一些私有的具体的子类组成在一个公开的抽象父类之下的架构。抽象的父类声明方法来创建私有子类的实例。父类会根据创建方法的调用来分发适当的具体子类对象。每个对象都会返回可能属于不同私有具体的子类。  
Cocoa中的类簇会根据不同情况只生成能够存储数据的对象。Foundation框架中对于NSString, NSData, NSDictionary, NSSet, 和 NSArray都有类簇。公开的父类包含了这些不可变类，同样也附有可变类 NSMutableString, NSMutableData, NSMutableDictionary, NSMutableSet, 和 NSMutableArray。  

##### 使用和局限

当你要创建由类簇表示的可变或不可变类型的对象时，你会用到一个类簇的公开类。对于类簇，简单性和可扩展性之间有一个权衡。类簇简化了一个类的接口，使得其容易学习和使用。不过，这使得要创建一个类簇的抽象父类的自定义子类变得困难了。  

```
深度阅读：“类簇”提供了更多关于Cocoa中的类簇相关信息。
```

### 适配器模式

适配器设计模式会将一个类的接口根据客户端所需转换成另一个接口。适配器会让类共同协作，否则由于接口不兼容而无法协作。它将客户端与目标对象的类脱钩。

#### 协议

协议是一个语言级别的（OC）功能，它能够定义适配器模式实例的接口。一条协议本质上是无关类的一系列方法声明。（在Java中，接口与协议相同。）如过你想要一个能够与另一个对象沟通的客户端对象，但对象的接口兼容很困难，你就可以定义一个协议。其他对象的类声明采纳协议，实现一个或多个该协议的方法。协议可能需要遵循它的类实现某些它的方法，让其他的可选方法不实现。客户端对象随后可以通过协议接口发送给其他对象对应消息。  
协议创造了一组不依赖于类层级的方法声明。它使得给予符合协议以及类继承对对象进行分组成为可能。NSObject 的conformsToProtocol: 方法能够让你检测一个对象的协议隶属关系。  
Cocoa有非正式协议，也有正式协议。非正式协议是NSObject 类的一个分类，这让任何对象都有潜在的实现任何分类中方法的能力(参见“分类”)。非正式协议中的方法能够被选择性的实现。非正式协议在OSX（参见“代理”）的代理机制中是实现的一部分。  
注意协议的设计不能够完美的匹配适配器模式的描述。但它达到了模式的目的：让具有与其他不同接口的类协同工作。

##### 使用和局限

使用协议主要是为了声明一个接口用来分层不相关的类，并希望这些类遵循协议来进行通讯。不过你也可以使用协议来给一个对象声明接口来隐藏其类别。Cocoa框架包含了很多正式协议能够自定义子类使其能够与特定的目标进行沟通。比如，Foundation框架包含了 NSObject, NSCopying, 和 NSCoding 协议，这些都很重要。AppKit 协议包含 NSDraggingInfo, NSTextInput, 和 NSChangeSpelling。UIKit协议包含 UITextInputTraits, UIWebViewDelegate, 和 UITableViewDataSource。  
正式协议隐含的需要遵循它的类要实现所有声明的方法。不过，它也能够使用@optional编译器指令标记一个或一组方法，遵循的类可以选择实现这些方法。不过这也变得不稳定，一旦你声明了一个协议，让其对于其他类变得可用，未来对其进行改变的话（期待额外的可选方法）就可能让这些类崩溃。

```
深度阅读：更多关于正式协议的相关信息，参见《OC编程语言》中的“协议”一节。
```

### 响应者链模式

响应者链设计模式通过给予更多的对象以机会来处理请求将一个请求的发送者从其接收者那里进行解耦。模式约束了接收者对象，并将请求沿着链条进行传递，直到一个对象对其进行处理。每个在链条中的对象要么处理请求，要么将其传递给链条中的下一个对象。  

#### 响应链

应用程序的框架包含了被称作响应者链的架构。这个链条由一系列响应者对象组成（意思是对象继承自NSResponder, 在 UIKit中继承自 UIResponder），其中传递事件（比如点击鼠标）或者行动消息的传递最终处理。如果一个给定的响应对象不能够处理一个特定消息，他会将消息传递给链条上的下一个响应者。链条中的响应对象的顺序通常由视图层级决定，从层级中的最低级到最高级的响应者，最终由管理视图层级的window对象决定，window对象的代理或者最终目标是应用程序对象。响应者链上的事件的路径和动作消息不同。一个应用能够拥有尽可能多的响应链，因为它有window（甚至本地视图层级）；但一次只能激活一个响应链——与当前窗口关联的活动window。  
AppKit框架同样也能够为错误传递实现类似的响应链。  

```
iOS注意：UIKit实现的响应链和AppKit实现的不同。如果一个视图被UIViewController对象所管理，视图控制器将会编程在链条中的下一个响应者（并从此处事件或者动作消息传递给视图的父视图）。此外，UIKit不支持文档架构本身；因此在响应者链条中没有文档对象或者窗口控制器对象。在iOS中也没有错误处理响应链条。
```
视图层级的设计与响应链条密切相关，采用的是复合模式。动作消息——来自控件对象的消息——基于目标-动作的机制，这是命令模式的一个实例。

##### 使用和局限

当你为一个程序构建用户界面时（无论是界面构建器还是编程方式），你都会隐形的获得一个或多个响应链。响应链在视图层级中相互关联的，当你创建一个窗口的内容视图的子视图对象时你就自动获得了。如果你将一个自定义视图添加到一个视图层级中时，它会变成响应者链条的一部分。如果你实现了NSResponder 或 UIResponder 方法的话，你就能接收处理事件和动作消息了。一个自定义的对象是一个窗口对象的代理或全局应用对象（AppKit中的NSApp）也能够接受和处理这些消息。  
你还可以以编程的方式注入自定义响应者到响应链中，也可以操纵响应链的顺序。

```
深度阅读：AppKit框架的响应者链处理事件和动作消息，并处理《Cocoa事件处理指南》和《错误处理编程指南》中描述的错误信息。UIKit响应链是在《iOS事件处理指南》有相关描述。视图层级是一个相关联的设计模式，在“复合”部分有描述。
```

### 命令模式

命令设计模式封装了请求作为对象，从而允许你用不同的请求、队列或者日志请求对客户端进行参数化，并支持可撤销的操作。请求对象将特定接收器上的一个或多个进行绑定。命令模式将接收和执行该请求的对象分离。  

#### Invocation对象

NSInvocation 类的实例封装了一个OC消息。invocation对象包含目标对象，方法选择器和方法参数。你可以通过invocation对象动态的改变分发的消息的目标和参数；一旦invocation被执行，你还可以从对象获取到返回值。通过一个invocation对象，你可以用不同的目标和参数重复的调用消息。  
NSInvocation 对象的创建需要NSMethodSignature 对象，它是一个封装与参数相关的类型信息的对象，并返回一个方法。反过来说，NSMethodSignature 对象是由一个方法选择器创建的。NSInvocation的实现也利用了OC运行时的功能。  

##### 使用和局限

NSInvocation对象是分发对象、撤销管理、消息转发和计时器的编程接口的一部分。在你需要解藕发送消息的对象和接受消息的对象时也可以使用invocation对象在这种类似上下文中。  
分发对象技术是为了中间处理交流。参见“Proxy”了解更多关于分发对象的信息。

```
深度阅读：《NSInvocation类参考》了解invocation对象详情。同样，可以查看一下文档来了解相关技术的信息：《撤销架构》，《Timer编程话题》和《OC编程语言》中的“运行时系统”部分。
```

### 目标-动作机制

目标-动作机制能够让一个控件对象——就是指类似一个按钮、滑块或者输入框——发送消息给另一个能够将消息作为一个应用程序特有命令的响应并处理的对象。接收对象或者目标同产是一个自定义的控制器对象。消息——称作一个动作消息——被一个选择器判断，选择器是一个运行时唯一ID的方法。  
在AppKit框架中，cell对象通常拥有封装目标和操作。当用户点击或以其他方法激活控件的时候，控件从其单元格中提取信息并发送消息。（菜单项也封装了目标和动作，并在用户选择它的时候发送操作消息。）目标-动作机制能够基于选择器工作（而非方法签名），因为按照惯例，在AppKit中签名的操作方法总是相同的。  
在UIKit中，目标-动作机制不会依赖于单元格。取而代之的，控件将目标和动作映射到控件上可能发生的一个或多个多点触摸事件上。  

#### 使用和局限

当创建Cocoa应用时，你可以通过界面构建器应用设置控件的行为和目标。所以你能够让控件在初始化的时候自定义行为，而无需编写控件本身的任何代码。动作选择器和目标连接存档在nib文件中，并在nib文件解档的时候还原。你还可以通过发送给控件或其cell setTarget: 和 setAction: 消息来动态的改变目标和动作。  
一个OSX的Cocoa应用能够使用目标-动作机制来构建自定义控制器对象来从用户界面到模型对象转移数据，或者在模型对象中展示数据。Cocoa绑定技术无需为此目的使用目标-动作。参见《Cocoa绑定编程话题》了解更多此技术。  
控件和cell不会持有它的目标。参见“代理的所有权，监听和目标”进一步阅读。

```
深度阅读：参见“目标动作机制”了解进一步的信息。
```

### 复合模式

复合设计模式将相关对象组成树形结构，以表示部分-整体的层次结构。这种模式让客户端统一处理对象的单个对象和组成。  
复合设计模式是MVC总体模式的一部分，这在《MVC设计模式》有详细描述。  

#### 视图层级

视图（NSView 或 UIView 对象）在窗口中内部构建了视图层级。在层级的根部是一个窗口（NSWindow 或 UIWindow 对象）和其内容视图，一个透明的视图，填充了窗口的内容矩形区域。被添加到内容视图的视图变成了它的子视图，内容视图变成了添加到它的视图的父视图。除了内容视图，一个视图有一个（且仅有一个）父视图，并且可以没有或有任意数量的子视图。你可以认为这种结构为包含：父视图包含其子视图。图4-2展示了视图层级结构的视觉和结构方面。    

图4-2 视图层级，可视化和结构  

![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/view_hierarchy.gif)    

视图层级是一种结构化的架构，它在绘制和事件处理中都扮演了部分角色。一个视图有两个边界矩形，它的frame和bounds，这影响了图形与视图的操作方式。框架是外部边界；它将视图定位在父视图的坐标系统中，定义了它的大小，并将裁剪绘制到视图的边缘。而bounds是内部的边界矩形，定义了视图本身绘制的表面的内部坐标系统。    
当窗口被窗口系统要求准备好展示其本身的时候，父视图也被要求在其子视图之前渲染其本身。当你发送某些消息给一个视图的时候——比如，请求一个视图重绘其本身的消息——消息会传递给其子视图。你可以将视图层次结构的分支视为统一视图。  
视图层级也经常被响应链用来处理事件和动作消息。参见《链条的职责》中的“响应链”相关概述。

##### 使用和局限

当你添加一个视图到另一个视图时，你就创建或修改了视图层级，无论是编码还是使用界面构建器。AppKit框架自动的处理所有的和视图层级相关的关系。  

```
深度阅读：《Cocoa绘制指南》讨论了在Mac应用中的视图层级。
```

### 装饰器模式

装饰器设计模式动态的给一个对象附加了额外的能力。装饰器提供了一个灵活的可替代子类的扩展功能。与子类一样，对装饰器模式的适配让你在不修改现有代码的情况下采用新的行为。装饰器包装了行为延伸了类的对象。它实现了与包装对象同样的接口，并在将任务委托给包装对象之前或之后添加了自己的行为。装饰器模式表达了设计原则，即类应该开放给扩展，但关闭修改。

#### General Comments

装饰器对于对象的构成而言是一种模式，我们也建议你在你自己的代码中这么做（参见“何时该创建子类”）。不过，Cocoa 本身提供了一些类和机制（在后续章节中讨论）是基于这种模式的。在这些实现中，扩展的对象不完全重复其封装的对象的接口，且其实现使用了不同的接口共享技术。  
Cocoa 使用装饰模式在实现以下几个类当中，包括 NSAttributedString, NSScrollView, 和 UIDatePicker。后面的两个类是两个复合视图的例子，它们将其他视图类的简单对象组合在一起并协调其相互作用。

#### 代理

代理是一种机制，主对象将一个弱引用（此处的弱引用指的是指针引用，unretained）嵌入到另一个对象——它的代理——并在任务需要输入时定期向代理发送消息。主对象通常是一个“现成的”框架对象（比如NSWindow 或 NSXMLParser对象）它试图完成某些工作，但它只能以通用的方式完成。代理，通常是一个自定义类的实例，扮演着协调主对象，在某个任务的特定点上支持特定程序行为的角色。因此代理是能够修改或者扩展另一个对象的行为的，而不用子类化。  

图4-3 框架对象发送消息给它的代理  

![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/delegation.gif)

委托，简单的说，就是一个对象将任务委托给另一个对象，是面向对象编程中的一种常见技术。不过，Cocoa以一种独特的方式实现了代理。主类使用了正式或非正式协议来定义接口让代理对象选择实现。在非正式协议中的所有方法都是可选的，正式协议也可能声明可选方法，让代理只实现协议中的部分方法。在试图发送消息给代理之前，主对象应该判断它是否实现了方法（通过respondsToSelector: 方法）来避免运行时异常。更多有关正式和非正式协议，参见“协议”部分。  
Cocoa框架中的一些类也会发送消息给其数据源。数据源在所有方面都与代理相同，只是其意图是给主对象提供填充浏览、表视图或类似的用户界面。与代理不同，数据源可能需要实现某些协议中的方法。  
代理并非装饰模式的严格实现。主对象（代理）不会包装一个它想要扩展的类的实例；事实上，这是一种相反的方式，因为代理指定类代理框架类的行为。除了框架类声明的代理方法外，是没有其他共享的接口的。   
Cocoa中的代理也是模板方法的一部分（“模板方法”）。

##### 使用和局限

在Cocoa框架中，代理是一种常见的设计模式。很多在AppKit和UIKit框架中的类都会发送消息给代理，包括 NSApplication, UIApplication, UITableView 和NSView的一些子类。某些在Foundation框架中的类，比如NSXMLParser 和 NSStream，也会维护代理。你应当始终使用类的代理机制代替类的子类机制，除非代理方法不能够让你完成你的目的。  
尽管你可以动态的改变代理，在同一时刻只有一个对象可以被代理。所以如果你想要在同一时间多个对象被一个特定的程序事件通知到，那你就不要使用代理。不过，你可以在这种情况下使用通知机制。代理会自动的从其代理框架对象接收消息，只要代理实现了一个或多个框架类中声明的通知方法。参见 监听模式（“监听”）中讨论的通知。  
在AppKit中的代理对象不会持有它的代理或者数据源。参见“代理的所有权，监听和目标”了解更多信息。  

```
深度阅读：更多关于代理的信息，参见“代理和数据源”。
```

#### 分类

分类是OC语言的一个功能，它能够让你添加方法（接口和实现）给一个类而无需创建子类。在运行时是没有区别的——在你程序的范围中——在类的原来的方法和添加到分类中的方法之间。分类中的方法会变成类型方法的一部分并被所有该类的子类继承。  
和代理一样，分类不是一个严格的装饰模式的适配，满足意图，而是采取不同的途径来实现这一意图。通过分类添加的行为是编译时的工作，而非动态获取的。此外，分类不封装正在扩展的类实例。  

##### 使用和局限

Cocoa框架定义了很多分类，它们中的大部分都是非正式协议（在“协议”一节概述）。通常使用分类来组织相关的方法。你可以在你的代码中实现分类来扩展类，而无需继承或分组相关的方法。不过，你应该意识到这些说明：  

* 你不能添加实例变量给类。
* 如果你重载了在类中已经存在的方法，你的程序的行为可能会不可预测。

```
深度阅读：参见《OC编程语言》中的“定义一个类”部分，来了解更多关于分类的信息。
```

### 外观模式

外观设计模式在一个子系统当中给一组接口提供了一个统一的接口。这种设计模式定义了一个高层的接口，通过降低子系统之间的复杂度和隐藏沟通和依赖来让子系统更容易使用。  

#### NSImage

AppKit 框架的NSImage类提供了统一的接口来加载和使用图片，这是可以基于位图（比如JPEG，PNG或TIFF格式）或矢量图（比如EPS或者PDF格式）的。NSImage能够保持超过一种同样图片的展现方式；每种展现方式都是一种 NSImageRep 对象的类型。NSImage 会为给定的展示设备和特定类型的数据自动的选择适当的展现方式。它也隐藏了图片操作和选择的细节，以便让客户端能够使用多种不同的底层可交换的展现方式。  

##### 使用和局限

由于NSImage支持多种不同的有关一个图片是什么的展示方式，某些请求属性可能不会响应。比如，如果底层图片的展示是基于适量的并与设备无关，那么让一个图片展示一个像素的颜色就没什么作用。  

```
注意：参见《Cocoa绘制指南》中关于NSImage的讨论以及图片展示部分。  
```

### 迭代模式

迭代设计模式提供了一种方法来顺序的访问集群对象（也就是集合）的元素而无需暴露其底层实现。迭代模式将访问和穿越集合对象的责任从集合本身交给了迭代对象。迭代器定义了接口来访问集合元素并跟踪当前元素。不同的迭代器能够执行不同的穿越策略。  

#### Enumerators

Foundation框架中的 NSEnumerator 类实现了迭代模式。抽象了NSEnumator类的私有、具体子类将按照顺序穿过各种类型的集合——数组、集合、字典（键值对）——的列举返回到客户端。   
NSDirectoryEnumerator 是一个遥远的相关类。该类的实例会在文件系统中递归枚举一个目录的内容。

##### 使用和局限

类似 NSArray, NSSet, 和 NSDictionary 的集合类包含的方法会返回一个适合集合类型的枚举器。所有的枚举器都是以同样的方式运行的。在循环中发送一个 nextObject 消息给枚举对象，当为nil时返回退出，否则返回集合中的下一个对象。   
你还可以使用快速枚举来访问集合的元素；这一语言特性在《快速枚举》中有描述。

### 中介模式

中介设计模式定义了一个封装如何让一组相互作用的对象的对象。中介通过保持对象之间的显式引用促进了低耦合，并让你独立的改变他们之间的相互作用。这些对象能够变得更加可重用。  
一个“中介对象”在这种模式下在系统中的对象之间集成了复杂交互和控制逻辑。这些对象会在状态改变以及响应从中介对象的请求时告诉中介对象。  

#### AppKit框架中的控制器类

MVC设计模式赋值给类似应用的面向对象系统中的各个对象以角色。它们可以是模型对象，包含应用程序的数据并操纵数据；它们可以是视图对象，用来展示数据和响应用户交互；或者也可以是控制器对象，调和模型和视图对象。控制器对象是符合中介者模式的。  
在Cocoa中，控制器对象能够有两种常用类型：中介控制器或者协同控制器。中介控制器调和应用程序中的视图对象和模型对象之前的数据流。中介对象通常是NSController对象。协同控制器为应用实现了中心化的交互和控制逻辑，为框架对象扮演着代理、做为动作消息的目标。它们通常是 NSWindowController 对象或者某个NSObject子类的实例。用于它们对于一个特定程序是高度特殊的，协同控制器更倾向于不能够被复用。  
抽象类NSController 和其集成的子类在AppKit框架中是Cocoa绑定技术的一部分，它们会自动的

##### 使用和局限

#### UIKit框架中的视图控制器类

### 备忘录模式

#### 归档

##### 使用和局限

#### 属性列表序列化

##### 使用和局限

#### Core Data

##### 使用和局限

### 监听模式

#### 通知

##### 使用和局限

#### KVO

##### 使用和局限

### 代理模式

#### NSProxy

##### 使用和局限

### 前台模式

#### 实践中的前台模式

### 单例模式

#### 框架中的类

##### 使用和局限

### 模板方法

#### 重写框架方法

##### 使用和局限

#### OSX中的文档架构

##### 使用和局限

## MVC 设计模式

MVC 设计模式非常古老。它的变种在早期的 Smalltalk 就已经存在了。它是一种高层的模式，它只关心一个应用程序整体架构的本身和分类对象根据整体在应用中所扮演的角色。它也是一个复合模式，包含几个甚至更多的元素模式。

### MVC 对象的角色和关系

MVC 设计模式考虑了又三种类型的对象：模型对象，视图对象和控制器对象。MVC 设计模式定义了这几种类型对象在应用程序中的角色以及它们之间沟通的渠道。当设计一个应用的时候，一个主要的步骤就是选择——或者创建自定义类——从这三个组当中之一的对象。这三种类型的对象的每一种都与其他的通过抽象的边界相分离，并且通过这些边界与其他类型进行通信。

#### 模型对象封装数据和基本行为

模型队形代表了特定的信息和专长。它们持有一个应用的数据，定义了操作数据的逻辑。一个设计良好的 MVC 应用会将其所有的重要数据都封装到模型数据中。任何属于应用持续状态部分的数据（不论持续状态是存在文件还是数据库中）都应该存到模型对象中，只要数据被加载到应用程序中。因为它们代表与一个特定专题相关的信息和专长，它们更倾向于被重用。  
比较理想的情况是，一个模型对象并不直接链接到用于展示和编辑的用户界面。比如，如果你有一个表示人的模型对象（假设你正在编写一个地址簿），你可能需要存储一个生日。在你的 Person 模型对象中存储可能比较好。不过，存储一个日期格式化的字符串或者其他信息。  
在实际情况下，

```
深度阅读：《模型对象实现指南》讨论了模型对象的更好的设计以及实现。
```

#### 视图对象展现信息给用户

一个视图对象要知晓如何展示，以及可能会允许用户编辑从应用程序模型中的数据。视图不应该负责存储展示的数据。（这并不意味着视图永远不应该存储展示的数据。视图可以缓存数据或者出于性能的原因做类似的事。）视图对象能够负责展示一个模型对象的一部分数据，或者整个模型对象，甚至多个不同的模型对象。视图

#### 控制器对象将模型绑定视图

#### 复合角色



```
深度阅读：《基于文档的应用程序概览》从另一个角度讨论了一个模型控制器对象和一个视图控制器对象之间的区别。
```

### Cocoa 控制器对象的类型



### MVC 作为一个复合设计模式



![](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/Art/traditional_mvc.gif)

### MVC 应用的设计指南

### MVC 在Cocoa中（OS X）

## 对象模型

### 实体

### 属性

### 关系

#### 关系的基数和所有权



### 访问属性

#### 键

#### 值

#### 键路径

# 与对象交互